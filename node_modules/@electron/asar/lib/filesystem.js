"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Filesystem = void 0;
const os = require("os");
const path = require("path");
const util_1 = require("util");
const stream = require("stream");
const integrity_1 = require("./integrity");
const wrapped_fs_1 = require("./wrapped-fs");
const UINT32_MAX = 2 ** 32 - 1;
const pipeline = (0, util_1.promisify)(stream.pipeline);
class Filesystem {
    constructor(src) {
        this.src = path.resolve(src);
        this.header = { files: Object.create(null) };
        this.headerSize = 0;
        this.offset = BigInt(0);
    }
    getRootPath() {
        return this.src;
    }
    getHeader() {
        return this.header;
    }
    getHeaderSize() {
        return this.headerSize;
    }
    setHeader(header, headerSize) {
        this.header = header;
        this.headerSize = headerSize;
    }
    searchNodeFromDirectory(p) {
        let json = this.header;
        const dirs = p.split(path.sep);
        for (const dir of dirs) {
            if (dir !== '.') {
                if ('files' in json) {
                    if (!json.files[dir]) {
                        json.files[dir] = { files: Object.create(null) };
                    }
                    json = json.files[dir];
                }
                else {
                    throw new Error('Unexpected directory state while traversing: ' + p);
                }
            }
        }
        return json;
    }
    searchNodeFromPath(p) {
        p = path.relative(this.src, p);
        if (!p) {
            return this.header;
        }
        const name = path.basename(p);
        const node = this.searchNodeFromDirectory(path.dirname(p));
        if (!node.files) {
            node.files = Object.create(null);
        }
        if (!node.files[name]) {
            node.files[name] = Object.create(null);
        }
        return node.files[name];
    }
    insertDirectory(p, shouldUnpack) {
        const node = this.searchNodeFromPath(p);
        if (shouldUnpack) {
            node.unpacked = shouldUnpack;
        }
        node.files = node.files || Object.create(null);
        return node.files;
    }
    async insertFile(p, shouldUnpack, file, options = {}) {
        const dirNode = this.searchNodeFromPath(path.dirname(p));
        const node = this.searchNodeFromPath(p);
        if (shouldUnpack || dirNode.unpacked) {
            node.size = file.stat.size;
            node.unpacked = true;
            node.integrity = await (0, integrity_1.getFileIntegrity)(p);
            return Promise.resolve();
        }
        let size;
        const transformed = options.transform && options.transform(p);
        if (transformed) {
            const tmpdir = await wrapped_fs_1.default.mkdtemp(path.join(os.tmpdir(), 'asar-'));
            const tmpfile = path.join(tmpdir, path.basename(p));
            const out = wrapped_fs_1.default.createWriteStream(tmpfile);
            const readStream = wrapped_fs_1.default.createReadStream(p);
            await pipeline(readStream, transformed, out);
            file.transformed = {
                path: tmpfile,
                stat: await wrapped_fs_1.default.lstat(tmpfile),
            };
            size = file.transformed.stat.size;
        }
        else {
            size = file.stat.size;
        }
        // JavaScript cannot precisely present integers >= UINT32_MAX.
        if (size > UINT32_MAX) {
            throw new Error(`${p}: file size can not be larger than 4.2GB`);
        }
        node.size = size;
        node.offset = this.offset.toString();
        node.integrity = await (0, integrity_1.getFileIntegrity)(p);
        if (process.platform !== 'win32' && file.stat.mode & 0o100) {
            node.executable = true;
        }
        this.offset += BigInt(size);
    }
    insertLink(p) {
        const symlink = wrapped_fs_1.default.readlinkSync(p);
        // /var => /private/var
        const parentPath = wrapped_fs_1.default.realpathSync(path.dirname(p));
        const link = path.relative(wrapped_fs_1.default.realpathSync(this.src), path.join(parentPath, symlink));
        if (link.startsWith('..')) {
            throw new Error(`${p}: file "${link}" links out of the package`);
        }
        const node = this.searchNodeFromPath(p);
        node.link = link;
        return link;
    }
    listFiles(options) {
        const files = [];
        const fillFilesFromMetadata = function (basePath, metadata) {
            if (!('files' in metadata)) {
                return;
            }
            for (const [childPath, childMetadata] of Object.entries(metadata.files)) {
                const fullPath = path.join(basePath, childPath);
                const packState = 'unpacked' in childMetadata && childMetadata.unpacked ? 'unpack' : 'pack  ';
                files.push(options && options.isPack ? `${packState} : ${fullPath}` : fullPath);
                fillFilesFromMetadata(fullPath, childMetadata);
            }
        };
        fillFilesFromMetadata('/', this.header);
        return files;
    }
    getNode(p) {
        const node = this.searchNodeFromDirectory(path.dirname(p));
        const name = path.basename(p);
        if (name) {
            return node.files[name];
        }
        else {
            return node;
        }
    }
    getFile(p, followLinks = true) {
        const info = this.getNode(p);
        if (!info) {
            throw new Error(`"${p}" was not found in this archive`);
        }
        // if followLinks is false we don't resolve symlinks
        if ('link' in info && followLinks) {
            return this.getFile(info.link, followLinks);
        }
        else {
            return info;
        }
    }
}
exports.Filesystem = Filesystem;
//# sourceMappingURL=filesystem.js.map